/*
  knockback.js 1.0.0
  Copyright (c)  2011-2015 Kevin Malakoff.
  License: MIT (http://www.opensource.org/licenses/mit-license.php)
  Source: https://github.com/kmalakoff/knockback
  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
*/
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("knockout"), require("backbone"), require("underscore"), (function webpackLoadOptionalExternalModule() {}()));
	else if(typeof define === 'function' && define.amd)
		define(["knockout", "backbone", "underscore"], function webpackLoadOptionalExternalModuleAmd(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_6__) {});
	else if(typeof exports === 'object')
		exports["kb"] = factory(require("knockout"), require("backbone"), require("underscore"), (function webpackLoadOptionalExternalModule() {}()));
	else
		root["kb"] = factory(root["ko"], root["Backbone"], root["_"], root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_7__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	__webpack_require__(8);
	__webpack_require__(12);
	__webpack_require__(13);
	__webpack_require__(14);
	__webpack_require__(2);
	__webpack_require__(15);
	__webpack_require__(16);
	__webpack_require__(18);
	__webpack_require__(19);
	__webpack_require__(17);
	__webpack_require__(20);
	__webpack_require__(24);
	__webpack_require__(25);
	__webpack_require__(27);
	__webpack_require__(28);
	__webpack_require__(29);
	__webpack_require__(30);
	module.exports = __webpack_require__(32);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var COMPARE_ASCENDING, COMPARE_DESCENDING, COMPARE_EQUAL, KEYS_PUBLISH, _, kb, ko, ref,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  indexOf = [].indexOf || function(item) {};

	ref = kb = __webpack_require__(2), _ = ref._, ko = ref.ko;

	COMPARE_EQUAL = 0;

	COMPARE_ASCENDING = -1;

	COMPARE_DESCENDING = 1;

	KEYS_PUBLISH = ['destroy', 'shareOptions', 'filters', 'comparator', 'sortAttribute', 'viewModelByModel', 'hasViewModels'];

	kb.compare = function(value_a, value_b) {};

	kb.CollectionObservable = (function() {
	  CollectionObservable.extend = kb.extend;

	  function CollectionObservable(collection, view_model, options) {
	    this._onCollectionChange = bind(this._onCollectionChange, this);
	    var args;
	    args = Array.prototype.slice.call(_.isArguments(collection) ? collection : arguments);
	    return kb.ignore((function(_this) {
	      return function() {
	        var arg, create_options, i, len, observable;
	        collection = args[0] instanceof kb.Collection ? args.shift() : (_.isArray(args[0]) ? new kb.Collection(args.shift()) : new kb.Collection());
	        if (_.isFunction(args[0])) {
	          args[0] = {
	            view_model: args[0]
	          };
	        }
	        options = {};
	        for (i = 0, len = args.length; i < len; i++) {
	          arg = args[i];
	          _.extend(options, arg);
	        }
	        observable = kb.utils.wrappedObservable(_this, ko.observableArray([]));
	        observable.__kb_is_co = true;
	        _this.in_edit = 0;
	        _this.__kb || (_this.__kb = {});
	        options = kb.utils.collapseOptions(options);
	        if (options.auto_compact) {
	          _this.auto_compact = true;
	        }
	        if (options.sort_attribute) {
	          _this._comparator = ko.observable(_this._attributeComparator(options.sort_attribute));
	        } else {
	          _this._comparator = ko.observable(options.comparator);
	        }
	        if (options.filters) {
	          _this._filters = ko.observableArray(_.isArray(options.filters) ? options.filters : options.filters ? [options.filters] : void 0);
	        } else {
	          _this._filters = ko.observableArray([]);
	        }
	        create_options = _this.create_options = {
	          store: kb.Store.useOptionsOrCreate(options, collection, observable)
	        };
	        kb.utils.wrappedObject(observable, collection);
	        _this.path = options.path;
	        create_options.factory = kb.utils.wrappedFactory(observable, _this._shareOrCreateFactory(options));
	        create_options.path = kb.utils.pathJoin(options.path, 'models');
	        create_options.creator = create_options.factory.creatorForPath(null, create_options.path);
	        if (create_options.creator) {
	          _this.models_only = create_options.creator.models_only;
	        }
	        kb.publishMethods(observable, _this, KEYS_PUBLISH);
	        _this._collection = ko.observable(collection);
	        observable.collection = _this.collection = ko.computed({
	          read: function() {
	            return _this._collection();
	          },
	          write: function(new_collection) {}
	        });
	        if (collection) {
	          collection.bind('all', _this._onCollectionChange);
	        }
	        _this._mapper = ko.computed(function() {
	          var comparator, current_collection, filter, filters, j, len1, models, previous_view_models, view_models;
	          comparator = _this._comparator();
	          filters = _this._filters();
	          if (filters) {
	            for (j = 0, len1 = filters.length; j < len1; j++) {
	              filter = filters[j];
	              ko.utils.unwrapObservable(filter);
	            }
	          }
	          current_collection = _this._collection();
	          if (_this.in_edit) {
	            return;
	          }
	          observable = kb.utils.wrappedObservable(_this);
	          previous_view_models = kb.peek(observable);
	          if (current_collection) {
	            models = current_collection.models;
	          }
	          if (!models || (current_collection.models.length === 0)) {
	            view_models = [];
	          } else {
	            models = _.filter(models, function(model) {});
	            if (comparator) {
	              view_models = _.map(models, function(model) {}).sort(comparator);
	            } else {
	              if (_this.models_only) {
	                view_models = filters.length ? models : models.slice();
	              } else {
	                view_models = _.map(models, function(model) {});
	              }
	            }
	          }
	          _this.in_edit++;
	          observable(view_models);
	          _this.in_edit--;
	        });
	        observable.subscribe(_.bind(_this._onObservableArrayChange, _this));
	        !kb.statistics || kb.statistics.register('CollectionObservable', _this);
	        return observable;
	      };
	    })(this));
	  }

	  CollectionObservable.prototype.destroy = function() {};

	  CollectionObservable.prototype.shareOptions = function() {};

	  CollectionObservable.prototype.filters = function(filters) {};

	  CollectionObservable.prototype.comparator = function(comparator) {};

	  CollectionObservable.prototype.sortAttribute = function(sort_attribute) {};

	  CollectionObservable.prototype.viewModelByModel = function(model) {};

	  CollectionObservable.prototype.hasViewModels = function() {};

	  CollectionObservable.prototype.compact = function() {};

	  CollectionObservable.prototype._shareOrCreateFactory = function(options) {
	    var absolute_models_path, existing_creator, factories, factory;
	    absolute_models_path = kb.utils.pathJoin(options.path, 'models');
	    factories = options.factories;
	    if ((factory = options.factory)) {
	      if ((existing_creator = factory.creatorForPath(null, absolute_models_path)) && (!factories || (factories['models'] === existing_creator))) {
	        if (!factories) {
	          return factory;
	        }
	        if (factory.hasPathMappings(factories, options.path)) {
	          return factory;
	        }
	      }
	    }
	    factory = new kb.Factory(options.factory);
	    if (factories) {
	      factory.addPathMappings(factories, options.path);
	    }
	    if (!factory.creatorForPath(null, absolute_models_path)) {
	      if (options.hasOwnProperty('models_only')) {
	        if (options.models_only) {
	          factory.addPathMapping(absolute_models_path, {
	            models_only: true
	          });
	        } else {
	          factory.addPathMapping(absolute_models_path, kb.ViewModel);
	        }
	      } else if (options.view_model) {
	        factory.addPathMapping(absolute_models_path, options.view_model);
	      } else if (options.create) {
	        factory.addPathMapping(absolute_models_path, {
	          create: options.create
	        });
	      } else {
	        factory.addPathMapping(absolute_models_path, kb.ViewModel);
	      }
	    }
	    return factory;
	  };

	  CollectionObservable.prototype._onCollectionChange = function(event, arg) {
	    return kb.ignore((function(_this) {
	      return function() {
	        var collection, comparator, observable, view_model;
	        if (_this.in_edit || kb.wasReleased(_this)) {
	          return;
	        }
	        switch (event) {
	          case 'reset':
	            if (_this.auto_compact) {
	              _this.compact();
	            } else {
	              _this._collection.notifySubscribers(_this._collection());
	            }
	            break;
	          case 'sort':
	          case 'resort':
	            _this._collection.notifySubscribers(_this._collection());
	            break;
	          case 'new':
	          case 'add':
	            if (!_this._selectModel(arg)) {
	              return;
	            }
	            observable = kb.utils.wrappedObservable(_this);
	            collection = _this._collection();
	            if (collection.indexOf(arg) === -1) {
	              return;
	            }
	            if ((view_model = _this.viewModelByModel(arg))) {
	              return;
	            }
	            _this.in_edit++;
	            if ((comparator = _this._comparator())) {
	              observable().push(_this._createViewModel(arg));
	              observable.sort(comparator);
	            } else {
	              observable.splice(collection.indexOf(arg), 0, _this._createViewModel(arg));
	            }
	            _this.in_edit--;
	            break;
	          case 'remove':
	          case 'destroy':
	            _this._onModelRemove(arg);
	            break;
	          case 'change':
	            if (!_this._selectModel(arg)) {
	              return _this._onModelRemove(arg);
	            }
	            view_model = _this.models_only ? arg : _this.viewModelByModel(arg);
	            if (!view_model) {
	              return _this._onCollectionChange('add', arg);
	            }
	            if (!(comparator = _this._comparator())) {
	              return;
	            }
	            _this.in_edit++;
	            kb.utils.wrappedObservable(_this).sort(comparator);
	            _this.in_edit--;
	        }
	      };
	    })(this));
	  };

	  CollectionObservable.prototype._onModelRemove = function(model) {};

	  CollectionObservable.prototype._onObservableArrayChange = function(models_or_view_models) {};

	  CollectionObservable.prototype._attributeComparator = function(sort_attribute) {};

	  CollectionObservable.prototype._createViewModel = function(model) {};

	  CollectionObservable.prototype._selectModel = function(model) {};

	  return CollectionObservable;

	})();

	kb.collectionObservable = function(collection, view_model, options) {
	  return new kb.CollectionObservable(arguments);
	};

	kb.observableCollection = kb.collectionObservable;


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var Backbone, LIFECYCLE_METHODS, _, kb, ko, window;

	window = window != null ? window : global;

	ko = __webpack_require__(3);

	LIFECYCLE_METHODS = ['release', 'destroy', 'dispose'];

	module.exports = kb = (function() {
	  var ref;

	  function kb() {}

	  kb.VERSION = '1.0.0';

	  kb.TYPE_UNKNOWN = 0;

	  kb.TYPE_SIMPLE = 1;

	  kb.TYPE_ARRAY = 2;

	  kb.TYPE_MODEL = 3;

	  kb.TYPE_COLLECTION = 4;

	  kb.wasReleased = function(obj) {
	    return !obj || obj.__kb_released;
	  };

	  kb.isReleaseable = function(obj, depth) {};

	  kb.release = function(obj) {};

	  kb.releaseKeys = function(obj) {};

	  kb.releaseOnNodeRemove = function(view_model, node) {
	    view_model || kb._throwUnexpected(this, 'missing view model');
	    node || kb._throwUnexpected(this, 'missing node');
	    return ko.utils.domNodeDisposal.addDisposeCallback(node, function() {});
	  };

	  kb.renderTemplate = function(template, view_model, options) {};

	  kb.applyBindings = function(view_model, node) {
	    var child, children, i, len, ref;
	    if (node.length) {
	      ref = [document.createElement('div'), node], node = ref[0], children = ref[1];
	      for (i = 0, len = children.length; i < len; i++) {
	        child = children[i];
	        node.appendChild(child);
	      }
	    }
	    ko.applyBindings(view_model, node);
	    kb.releaseOnNodeRemove(view_model, node);
	    return node;
	  };

	  kb.getValue = function(model, key, args) {};

	  kb.setValue = function(model, key, value) {};

	  kb.ignore = ((ref = ko.dependencyDetection) != null ? ref.ignore : void 0) || function(callback, callbackTarget, callbackArgs) {};

	  kb.extend = __webpack_require__(4);

	  kb._throwMissing = function(instance, message) {};

	  kb._throwUnexpected = function(instance, message) {};

	  kb.publishMethods = function(observable, instance, methods) {
	    var fn, i, len;
	    for (i = 0, len = methods.length; i < len; i++) {
	      fn = methods[i];
	      observable[fn] = kb._.bind(instance[fn], instance);
	    }
	  };

	  kb.peek = function(obs) {
	    if (!ko.isObservable(obs)) {
	      return obs;
	    }
	    if (obs.peek) {
	      return obs.peek();
	    }
	    return kb.ignore(function() {});
	  };

	  kb.isModel = function(obj) {};

	  kb.isCollection = function(obj) {};

	  return kb;

	})();

	if (window.Parse) {
	  Backbone = kb.Parse = window.Parse;
	  _ = kb._ = window.Parse._;
	} else {
	  Backbone = kb.Backbone = __webpack_require__(5);
	  _ = kb._ = __webpack_require__(6);
	}

	kb.ko = ko;

	kb.Collection = Backbone.Collection;

	kb.Model = Backbone.Object || Backbone.Model;

	kb.Events = Backbone.Events;

	kb.$ = window.jQuery || window.$;

	try {
	  kb.$ || (kb.$ = __webpack_require__(7));
	} catch (undefined) {}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ },
/* 4 */
/***/ function(module, exports) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var copyProps;

	copyProps = function(dest, source) {
	  var key, value;
	  for (key in source) {
	    value = source[key];
	    dest[key] = value;
	  }
	  return dest;
	};

	// Shared empty constructor function to aid in prototype-chain creation.
	var ctor = function(){};

	// Helper function to correctly set up the prototype chain, for subclasses.
	// Similar to 'goog.inherits', but uses a hash of prototype properties and
	// class properties to be extended.
	var inherits = function(parent, protoProps, staticProps) {
	  var child;

	  // The constructor function for the new subclass is either defined by you
	  // (the "constructor" property in your extend definition), or defaulted
	  // by us to simply call the parent's constructor.
	  if (protoProps && protoProps.hasOwnProperty('constructor')) {
	    child = protoProps.constructor;
	  } else {
	    child = function(){};
	  }

	  // Inherit class (static) properties from parent.
	  copyProps(child, parent);

	  // Set the prototype chain to inherit from parent, without calling
	  // parent's constructor function.
	  ctor.prototype = parent.prototype;
	  child.prototype = new ctor();

	  // Add prototype properties (instance properties) to the subclass,
	  // if supplied.
	  if (protoProps) copyProps(child.prototype, protoProps);

	  // Add static properties to the constructor function, if supplied.
	  if (staticProps) copyProps(child, staticProps);

	  // Correctly set child's 'prototype.constructor'.
	  child.prototype.constructor = child;

	  // Set a convenience property in case the parent's prototype is needed later.
	  child.__super__ = parent.prototype;

	  return child;
	};

	// The self-propagating extend function that BacLCone classes use.
	var extend = function (protoProps, classProps) {
	  var child = inherits(this, protoProps, classProps);
	  child.extend = this.extend;
	  return child;
	};
	;

	module.exports = extend;


/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_5__;

/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_6__;

/***/ },
/* 7 */
/***/ function(module, exports) {},
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var ALL_ORMS, _, kb, key, ko, ref, value;

	ref = kb = __webpack_require__(2), _ = ref._, ko = ref.ko;

	ALL_ORMS = {
	  "default": null,
	  'backbone-orm': null,
	  'backbone-associations': __webpack_require__(9),
	  'backbone-relational': __webpack_require__(10),
	  supermodel: __webpack_require__(11)
	};

	kb.orm = ALL_ORMS["default"];

	for (key in ALL_ORMS) {
	  value = ALL_ORMS[key];
	  if (value && value.isAvailable()) {
	    kb.orm = value;
	    break;
	  }
	}

	module.exports = function(options) {};


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var AssociatedModel, Backbone, BackboneAssociations, _, kb, ref;

	ref = kb = __webpack_require__(2), _ = ref._, Backbone = ref.Backbone;

	AssociatedModel = null;

	module.exports = BackboneAssociations = (function() {
	  function BackboneAssociations() {}

	  BackboneAssociations.isAvailable = function() {
	    return !!(AssociatedModel = Backbone != null ? Backbone.AssociatedModel : void 0);
	  };

	  BackboneAssociations.keys = function(model) {};

	  BackboneAssociations.relationType = function(model, key) {};

	  BackboneAssociations.useFunction = function() {};

	  return BackboneAssociations;

	})();


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var Backbone, BackboneRelational, RelationalModel, _, kb, ref;

	ref = kb = __webpack_require__(2), _ = ref._, Backbone = ref.Backbone;

	RelationalModel = null;

	module.exports = BackboneRelational = (function() {
	  function BackboneRelational() {}

	  BackboneRelational.isAvailable = function() {
	    return !!(RelationalModel = Backbone != null ? Backbone.RelationalModel : void 0);
	  };

	  BackboneRelational.relationType = function(model, key) {};

	  BackboneRelational.bind = function(model, key, update, path) {};

	  BackboneRelational.useFunction = function() {};

	  return BackboneRelational;

	})();


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var Supermodel, _, kb, root;

	root = typeof window !== "undefined" && window !== null ? window : global;

	_ = (kb = __webpack_require__(2))._;

	Supermodel = null;

	module.exports = Supermodel = (function() {
	  function Supermodel() {}

	  Supermodel.isAvailable = function() {
	    return !!(Supermodel = root.Supermodel);
	  };

	  Supermodel.keys = function(model) {};

	  Supermodel.relationType = function(model, key) {};

	  Supermodel.bind = function(model, key, update, path) {};

	  Supermodel.useFunction = function(model, key) {};

	  return Supermodel;

	})();

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var _, kb, ko, ref,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

	ref = kb = __webpack_require__(2), _ = ref._, ko = ref.ko;

	kb.EventWatcher = (function() {
	  EventWatcher.useOptionsOrCreate = function(options, emitter, obj, callback_options) {};

	  function EventWatcher(emitter, obj, callback_options) {
	    this._unbindCallbacks = bind(this._unbindCallbacks, this);
	    this._onModelUnloaded = bind(this._onModelUnloaded, this);
	    this._onModelLoaded = bind(this._onModelLoaded, this);
	    this.__kb || (this.__kb = {});
	    this.__kb.callbacks = {};
	    this.ee = null;
	    if (callback_options) {
	      this.registerCallbacks(obj, callback_options);
	    }
	    if (emitter) {
	      this.emitter(emitter);
	    }
	  }

	  EventWatcher.prototype.destroy = function() {};

	  EventWatcher.prototype.emitter = function(new_emitter) {
	    if ((arguments.length === 0) || (this.ee === new_emitter)) {
	      return this.ee;
	    }
	    if (this.model_ref) {
	      this.model_ref.unbind('loaded', this._onModelLoaded);
	      this.model_ref.unbind('unloaded', this._onModelUnloaded);
	      this.model_ref.release();
	      this.model_ref = null;
	    }
	    if (kb.Backbone && kb.Backbone.ModelRef && (new_emitter instanceof kb.Backbone.ModelRef)) {
	      this.model_ref = new_emitter;
	      this.model_ref.retain();
	      this.model_ref.bind('loaded', this._onModelLoaded);
	      this.model_ref.bind('unloaded', this._onModelUnloaded);
	      new_emitter = this.model_ref.model() || null;
	    } else {
	      delete this.model_ref;
	    }
	    if (this.ee !== new_emitter) {
	      if (new_emitter) {
	        this._onModelLoaded(new_emitter);
	      } else {
	        this._onModelUnloaded(this.ee);
	      }
	    }
	    return new_emitter;
	  };

	  EventWatcher.prototype.registerCallbacks = function(obj, callback_info) {
	    var event_name, event_names, fn, i, len, model;
	    obj || kb._throwMissing(this, 'obj');
	    callback_info || kb._throwMissing(this, 'callback_info');
	    event_names = callback_info.event_selector ? callback_info.event_selector.split(' ') : ['change'];
	    model = this.ee;
	    fn = (function(_this) {
	      return function(event_name) {
	        var callbacks, info;
	        if (!(callbacks = _this.__kb.callbacks[event_name])) {
	          callbacks = _this.__kb.callbacks[event_name] = {
	            model: null,
	            list: [],
	            fn: function(model) {}
	          };
	        }
	        callbacks.list.push(info = _.defaults({
	          obj: obj
	        }, callback_info));
	        if (model) {
	          return _this._onModelLoaded(model);
	        }
	      };
	    })(this);
	    for (i = 0, len = event_names.length; i < len; i++) {
	      event_name = event_names[i];
	      if (!event_name) {
	        continue;
	      }
	      fn(event_name);
	    }
	    return this;
	  };

	  EventWatcher.prototype.releaseCallbacks = function(obj) {};

	  EventWatcher.prototype._onModelLoaded = function(model) {
	    var callbacks, event_name, i, info, len, ref1, ref2, ref3;
	    this.ee = model;
	    ref1 = this.__kb.callbacks;
	    for (event_name in ref1) {
	      callbacks = ref1[event_name];
	      if (callbacks.model && (callbacks.model !== model)) {
	        this._unbindCallbacks(event_name, callbacks, true);
	      }
	      if (!callbacks.model) {
	        callbacks.model = model;
	        model.bind(event_name, callbacks.fn);
	      }
	      ref2 = callbacks.list;
	      for (i = 0, len = ref2.length; i < len; i++) {
	        info = ref2[i];
	        info.unbind_fn || (info.unbind_fn = (ref3 = kb.orm) != null ? ref3.bind(model, info.key, info.update, info.path) : void 0);
	        if (info.emitter) {
	          info.emitter(model);
	        }
	      }
	    }
	  };

	  EventWatcher.prototype._onModelUnloaded = function(model) {};

	  EventWatcher.prototype._unbindCallbacks = function(event_name, callbacks, skip_emitter) {};

	  return EventWatcher;

	})();

	kb.emitterObservable = function(emitter, observable) {};


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var _, kb;

	_ = (kb = __webpack_require__(2))._;

	kb.Factory = (function() {
	  Factory.useOptionsOrCreate = function(options, obj, owner_path) {
	    var factory;
	    if (options.factory && (!options.factories || (options.factories && options.factory.hasPathMappings(options.factories, owner_path)))) {
	      return kb.utils.wrappedFactory(obj, options.factory);
	    }
	    factory = kb.utils.wrappedFactory(obj, new kb.Factory(options.factory));
	    if (options.factories) {
	      factory.addPathMappings(options.factories, owner_path);
	    }
	    return factory;
	  };

	  function Factory(parent_factory) {
	    this.paths = {};
	    if (parent_factory) {
	      this.parent_factory = parent_factory;
	    }
	  }

	  Factory.prototype.hasPath = function(path) {};

	  Factory.prototype.addPathMapping = function(path, create_info) {
	    return this.paths[path] = create_info;
	  };

	  Factory.prototype.addPathMappings = function(factories, owner_path) {};

	  Factory.prototype.hasPathMappings = function(factories, owner_path) {};

	  Factory.prototype.creatorForPath = function(obj, path) {
	    var creator, ref;
	    if (creator = this.paths[path]) {
	      return (creator.view_model ? creator.view_model : creator);
	    }
	    if (creator = (ref = this.parent_factory) != null ? ref.creatorForPath(obj, path) : void 0) {
	      return creator;
	    }
	    return null;
	  };

	  return Factory;

	})();


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var $, _, _ko_applyBindings, kb, ko, onReady, ref, window;

	window = window != null ? window : global;

	ref = kb = __webpack_require__(2), _ = ref._, ko = ref.ko, $ = ref.$;

	kb.RECUSIVE_AUTO_INJECT = true;

	ko.bindingHandlers['inject'] = {
	  'init': function(element, value_accessor, all_bindings_accessor, view_model) {}
	};

	kb.Inject = (function() {
	  function Inject() {}

	  Inject.inject = function(data, view_model, element, value_accessor, all_bindings_accessor, nested) {
	    var inject;
	    inject = function(data) {
	      var key, target, value;
	      if (_.isFunction(data)) {
	        view_model = new data(view_model, element, value_accessor, all_bindings_accessor);
	        kb.releaseOnNodeRemove(view_model, element);
	      } else {
	        if (data.view_model) {
	          view_model = new data.view_model(view_model, element, value_accessor, all_bindings_accessor);
	          kb.releaseOnNodeRemove(view_model, element);
	        }
	        for (key in data) {
	          value = data[key];
	          if (key === 'view_model') {
	            continue;
	          }
	          if (key === 'create') {
	            value(view_model, element, value_accessor, all_bindings_accessor);
	          } else if (_.isObject(value) && !_.isFunction(value)) {
	            target = nested || (value && value.create) ? {} : view_model;
	            view_model[key] = kb.Inject.inject(value, target, element, value_accessor, all_bindings_accessor, true);
	          } else {
	            view_model[key] = value;
	          }
	        }
	      }
	      return view_model;
	    };
	    if (nested) {
	      return inject(data);
	    } else {
	      return kb.ignore(function() {});
	    }
	  };

	  Inject.injectViewModels = function(root) {
	    var afterBinding, app, beforeBinding, data, expression, findElements, i, len, options, results;
	    results = [];
	    findElements = function(el) {
	      var attr, child_el, i, len, ref1;
	      if (!el.__kb_injected) {
	        if (el.attributes && (attr = _.find(el.attributes, function(attr) {
	          return attr.name === 'kb-inject';
	        }))) {
	          el.__kb_injected = true;
	          results.push({
	            el: el,
	            view_model: {},
	            binding: attr.value
	          });
	        }
	      }
	      ref1 = el.childNodes;
	      for (i = 0, len = ref1.length; i < len; i++) {
	        child_el = ref1[i];
	        findElements(child_el);
	      }
	    };
	    if (!root && (window != null ? window.document : void 0)) {
	      root = window.document;
	    }
	    findElements(root);
	    for (i = 0, len = results.length; i < len; i++) {
	      app = results[i];
	      if (expression = app.binding) {
	        (expression.search(/[:]/) < 0) || (expression = "{" + expression + "}");
	        data = (new Function("", "return ( " + expression + " )"))();
	        data || (data = {});
	        (!data.options) || (options = data.options, delete data.options);
	        options || (options = {});
	        app.view_model = kb.Inject.inject(data, app.view_model, app.el, null, null, true);
	        afterBinding = app.view_model.afterBinding || options.afterBinding;
	        beforeBinding = app.view_model.beforeBinding || options.beforeBinding;
	      }
	      if (beforeBinding) {
	        beforeBinding.call(app.view_model, app.view_model, app.el, options);
	      }
	      kb.applyBindings(app.view_model, app.el, options);
	      if (afterBinding) {
	        afterBinding.call(app.view_model, app.view_model, app.el, options);
	      }
	    }
	    return results;
	  };

	  return Inject;

	})();

	_ko_applyBindings = ko.applyBindings;

	ko.applyBindings = function(context, element) {
	  var results;
	  results = kb.RECUSIVE_AUTO_INJECT ? kb.injectViewModels(element) : [];
	  if (!results.length) {
	    return _ko_applyBindings.apply(this, arguments);
	  }
	};

	kb.injectViewModels = kb.Inject.injectViewModels;

	if (typeof document !== "undefined" && document !== null) {
	  if ($) {
	    $(function() {
	      return kb.injectViewModels();
	    });
	  } else {
	    (onReady = function() {})();
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var _extend, kb, ko, ref, ref1;

	ko = (kb = __webpack_require__(2)).ko;

	if ((ref = ko.subscribable) != null ? (ref1 = ref.fn) != null ? ref1.extend : void 0 : void 0) {
	  _extend = ko.subscribable.fn.extend;
	  ko.subscribable.fn.extend = function() {
	    var _dispose, target;
	    target = _extend.apply(this, arguments);
	    if (target !== this && kb.isReleaseable(this)) {
	      _dispose = target.dispose;
	      target.dispose = (function(_this) {})(this);
	    }
	    return target;
	  };
	}


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var KEYS_INFO, KEYS_PUBLISH, TypedValue, _, kb, ko, ref;

	ref = kb = __webpack_require__(2), _ = ref._, ko = ref.ko;

	TypedValue = __webpack_require__(17);

	KEYS_PUBLISH = ['value', 'valueType', 'destroy'];

	KEYS_INFO = ['args', 'read', 'write'];

	kb.Observable = (function() {
	  function Observable(model, key_or_info, options, _vm) {}

	  Observable.prototype.destroy = function() {};

	  Observable.prototype.value = function() {};

	  Observable.prototype.valueType = function() {};

	  Observable.prototype.update = function(new_value) {};

	  return Observable;

	})();

	kb.observable = function(model, key, options, view_model) {};


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var TypedValue, _, kb, ko, ref;

	ref = kb = __webpack_require__(2), _ = ref._, ko = ref.ko;

	module.exports = TypedValue = (function() {
	  function TypedValue(create_options1) {}

	  TypedValue.prototype.destroy = function() {};

	  TypedValue.prototype.value = function() {};

	  TypedValue.prototype.rawValue = function() {};

	  TypedValue.prototype.valueType = function(model, key) {};

	  TypedValue.prototype.update = function(new_value) {};

	  TypedValue.prototype._updateValueObservable = function(new_value, new_observable) {};

	  TypedValue.prototype._inferType = function(value) {};

	  return TypedValue;

	})();


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var _, kb;

	_ = (kb = __webpack_require__(2))._;

	module.exports = kb.Statistics = (function() {
	  function Statistics() {}

	  Statistics.prototype.clear = function() {};

	  Statistics.prototype.addModelEvent = function(event) {};

	  Statistics.prototype.modelEventsStatsString = function() {};

	  Statistics.prototype.register = function(key, obj) {};

	  Statistics.prototype.unregister = function(key, obj) {};

	  Statistics.prototype.registeredCount = function(type) {};

	  Statistics.prototype.registeredStatsString = function(success_message) {};

	  Statistics.prototype.registeredTracker = function(key) {};

	  Statistics.eventsStats = function(obj, key) {};

	  return Statistics;

	})();


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var _, kb, ko, ref;

	ref = kb = __webpack_require__(2), _ = ref._, ko = ref.ko;

	module.exports = kb.Store = (function() {
	  Store.instances = [];

	  Store.useOptionsOrCreate = function(options, obj, observable) {
	    var store;
	    if (!options.store) {
	      kb.utils.wrappedStoreIsOwned(observable, true);
	    }
	    store = kb.utils.wrappedStore(observable, options.store || new kb.Store());
	    store.retain(observable, obj, options.creator);
	    return store;
	  };

	  function Store() {
	    this.observable_records = {};
	    this.replaced_observables = [];
	    kb.Store.instances.push(this);
	  }

	  Store.prototype.destroy = function() {};

	  Store.prototype.clear = function() {};

	  Store.prototype.compact = function() {};

	  Store.prototype.retain = function(observable, obj, creator) {
	    var current_observable;
	    if (!this._canRegister(observable)) {
	      return;
	    }
	    creator || (creator = observable.constructor);
	    if (current_observable = this.find(obj, creator)) {
	      if (current_observable === observable) {
	        this._getOrCreateStoreReferences(observable).ref_count++;
	        return observable;
	      }
	      this._retire(current_observable);
	    }
	    this._add(observable, obj, creator);
	    this._getOrCreateStoreReferences(observable).ref_count++;
	    return observable;
	  };

	  Store.prototype.retainOrCreate = function(obj, options) {};

	  Store.prototype.reuse = function(observable, obj) {};

	  Store.prototype.release = function(observable, force) {};

	  Store.prototype.find = function(obj, creator) {
	    var observable, records, ref1;
	    if (!(records = this.observable_records[this._creatorId(creator)])) {
	      return null;
	    }
	    if ((ref1 = (observable = records[this._cid(obj)])) != null ? ref1.__kb_released : void 0) {
	      delete records[this._cid(obj)];
	      return null;
	    }
	    return observable;
	  };

	  Store.prototype._refCount = function(observable) {};

	  Store.prototype._canRegister = function(observable) {
	    return observable && !ko.isObservable(observable) && !observable.__kb_is_co;
	  };

	  Store.prototype._cid = function(obj) {
	    var cid;
	    return cid = obj ? obj.cid || (obj.cid = _.uniqueId('c')) : 'null';
	  };

	  Store.prototype._creatorId = function(creator) {
	    var create, i, item, len, ref1;
	    create = creator.create || creator;
	    create.__kb_cids || (create.__kb_cids = []);
	    ref1 = create.__kb_cids;
	    for (i = 0, len = ref1.length; i < len; i++) {
	      item = ref1[i];
	      if (item.create === create) {
	        return item.cid;
	      }
	    }
	    create.__kb_cids.push(item = {
	      create: create,
	      cid: _.uniqueId('kb')
	    });
	    return item.cid;
	  };

	  Store.prototype._storeReferences = function(observable) {};

	  Store.prototype._getOrCreateStoreReferences = function(observable) {
	    var store_references, stores_references;
	    stores_references = kb.utils.orSet(observable, 'stores_references', []);
	    if (!(store_references = _.find(stores_references, (function(_this) {
	      return function(store_references) {};
	    })(this)))) {
	      stores_references.push(store_references = {
	        store: this,
	        ref_count: 0,
	        release: (function(_this) {
	          return function() {};
	        })(this)
	      });
	    }
	    return store_references;
	  };

	  Store.prototype._clearStoreReferences = function(observable) {};

	  Store.prototype._retire = function(observable) {};

	  Store.prototype._add = function(observable, obj, creator) {
	    var base, name;
	    creator || (creator = observable.constructor);
	    kb.utils.wrappedObject(observable, obj);
	    kb.utils.wrappedCreator(observable, creator);
	    return ((base = this.observable_records)[name = this._creatorId(creator)] || (base[name] = {}))[this._cid(obj)] = observable;
	  };

	  Store.prototype._remove = function(observable) {};

	  Store.prototype._creator = function(obj, options) {};

	  return Store;

	})();


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var _, kb, ko, ref;

	ref = kb = __webpack_require__(2), _ = ref._, ko = ref.ko;

	kb.utils = (function() {
	  function utils() {}

	  utils.get = function(obj, key, default_value) {
	    if (!obj.__kb || !obj.__kb.hasOwnProperty(key)) {
	      return default_value;
	    } else {
	      return obj.__kb[key];
	    }
	  };

	  utils.set = function(obj, key, value) {
	    return (obj.__kb || (obj.__kb = {}))[key] = value;
	  };

	  utils.orSet = function(obj, key, value) {
	    if (!(obj.__kb || (obj.__kb = {})).hasOwnProperty(key)) {
	      obj.__kb[key] = value;
	    }
	    return obj.__kb[key];
	  };

	  utils.has = function(obj, key) {};

	  utils.wrappedObservable = function(obj, value) {
	    if (arguments.length === 1) {
	      return kb.utils.get(obj, 'observable');
	    } else {
	      return kb.utils.set(obj, 'observable', value);
	    }
	  };

	  utils.wrappedObject = function(obj, value) {
	    if (arguments.length === 1) {
	      return kb.utils.get(obj, 'object');
	    } else {
	      return kb.utils.set(obj, 'object', value);
	    }
	  };

	  utils.wrappedCreator = function(obj, value) {
	    if (arguments.length === 1) {
	      return kb.utils.get(obj, 'creator');
	    } else {
	      return kb.utils.set(obj, 'creator', value);
	    }
	  };

	  utils.wrappedModel = function(obj, value) {};

	  utils.wrappedStore = function(obj, value) {
	    if (arguments.length === 1) {
	      return kb.utils.get(obj, 'store');
	    } else {
	      return kb.utils.set(obj, 'store', value);
	    }
	  };

	  utils.wrappedStoreIsOwned = function(obj, value) {
	    if (arguments.length === 1) {
	      return kb.utils.get(obj, 'store_is_owned');
	    } else {
	      return kb.utils.set(obj, 'store_is_owned', value);
	    }
	  };

	  utils.wrappedFactory = function(obj, value) {
	    if (arguments.length === 1) {
	      return kb.utils.get(obj, 'factory');
	    } else {
	      return kb.utils.set(obj, 'factory', value);
	    }
	  };

	  utils.wrappedEventWatcher = function(obj, value) {
	    if (arguments.length === 1) {
	      return kb.utils.get(obj, 'event_watcher');
	    } else {
	      return kb.utils.set(obj, 'event_watcher', value);
	    }
	  };

	  utils.wrappedEventWatcherIsOwned = function(obj, value) {};

	  utils.wrappedDestroy = __webpack_require__(21);

	  utils.valueType = function(observable) {};

	  utils.pathJoin = function(path1, path2) {
	    return (path1 ? (path1[path1.length - 1] !== '.' ? path1 + "." : path1) : '') + path2;
	  };

	  utils.optionsPathJoin = function(options, path) {};

	  utils.inferCreator = function(value, factory, path) {};

	  utils.createFromDefaultCreator = function(obj, options) {};

	  utils.collapseOptions = __webpack_require__(22);

	  utils.unwrapModels = __webpack_require__(23);

	  utils.resolveModel = function(model) {};

	  return utils;

	})();


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var _, wrappedDestroy;

	_ = __webpack_require__(2)._;

	module.exports = wrappedDestroy = function(obj) {};


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var _, _keyArrayToObject, _mergeArray, _mergeObject, _mergeOptions;

	_ = __webpack_require__(2)._;

	_mergeArray = function(result, key, value) {};

	_mergeObject = function(result, key, value) {};

	_keyArrayToObject = function(value) {};

	_mergeOptions = function(result, options) {
	  var key, value;
	  if (!options) {
	    return result;
	  }
	  for (key in options) {
	    value = options[key];
	    switch (key) {
	      case 'internals':
	      case 'requires':
	      case 'excludes':
	      case 'statics':
	        _mergeArray(result, key, value);
	        break;
	      case 'keys':
	        if ((_.isObject(value) && !_.isArray(value)) || (_.isObject(result[key]) && !_.isArray(result[key]))) {
	          if (!_.isObject(value)) {
	            value = [value];
	          }
	          if (_.isArray(value)) {
	            value = _keyArrayToObject(value);
	          }
	          if (_.isArray(result[key])) {
	            result[key] = _keyArrayToObject(result[key]);
	          }
	          _mergeObject(result, key, value);
	        } else {
	          _mergeArray(result, key, value);
	        }
	        break;
	      case 'factories':
	        if (_.isFunction(value)) {
	          result[key] = value;
	        } else {
	          _mergeObject(result, key, value);
	        }
	        break;
	      case 'static_defaults':
	        _mergeObject(result, key, value);
	        break;
	      case 'options':
	        break;
	      default:
	        result[key] = value;
	    }
	  }
	  return _mergeOptions(result, options.options);
	};

	module.exports = function(options) {
	  return _mergeOptions({}, options);
	};


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var _, unwrapModels;

	_ = __webpack_require__(2)._;

	module.exports = unwrapModels = function(obj) {};


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var KEYS_OPTIONS, _, assignViewModelKey, createObservable, createStaticObservables, kb, ko, ref;

	ref = kb = __webpack_require__(2), _ = ref._, ko = ref.ko;

	assignViewModelKey = function(vm, key) {};

	createObservable = function(vm, model, key, create_options) {};

	createStaticObservables = function(vm, model) {};

	KEYS_OPTIONS = ['keys', 'internals', 'excludes', 'statics', 'static_defaults'];

	kb.ViewModel = (function() {
	  ViewModel.extend = kb.extend;

	  function ViewModel(model, options, view_model) {
	    var args;
	    if (options == null) {
	      options = {};
	    }
	    args = Array.prototype.slice.call(_.isArguments(model) ? model : arguments);
	    return kb.ignore((function(_this) {
	      return function() {
	        var _model, arg, event_watcher, i, j, key, len, len1;
	        !(model = args.shift()) || kb.isModel(model) || kb._throwUnexpected(_this, 'not a model');
	        if (_.isArray(args[0])) {
	          args[0] = {
	            keys: args[0]
	          };
	        }
	        _this.__kb || (_this.__kb = {});
	        _this.__kb.view_model = (args.length > 1 ? args.pop() : _this);
	        options = {};
	        for (i = 0, len = args.length; i < len; i++) {
	          arg = args[i];
	          _.extend(options, arg);
	        }
	        options = kb.utils.collapseOptions(options);
	        for (j = 0, len1 = KEYS_OPTIONS.length; j < len1; j++) {
	          key = KEYS_OPTIONS[j];
	          if (options.hasOwnProperty(key)) {
	            _this.__kb[key] = options[key];
	          }
	        }
	        kb.Store.useOptionsOrCreate(options, model, _this);
	        _this.__kb.path = options.path;
	        kb.Factory.useOptionsOrCreate(options, _this, options.path);
	        _model = kb.utils.set(_this, '_model', ko.observable());
	        _this.model = ko.computed({
	          read: function() {
	            return ko.utils.unwrapObservable(_model);
	          },
	          write: function(new_model) {}
	        });
	        event_watcher = kb.utils.wrappedEventWatcher(_this, new kb.EventWatcher(model, _this, {
	          emitter: _this._model,
	          update: (function() {})
	        }));
	        kb.utils.wrappedObject(_this, model = event_watcher.ee);
	        _model(event_watcher.ee);
	        _this.__kb.create_options = {
	          store: kb.utils.wrappedStore(_this),
	          factory: kb.utils.wrappedFactory(_this),
	          path: _this.__kb.path,
	          event_watcher: kb.utils.wrappedEventWatcher(_this)
	        };
	        !options.requires || _this.createObservables(model, options.requires);
	        !_this.__kb.internals || _this.createObservables(model, _this.__kb.internals);
	        !options.mappings || _this.createObservables(model, options.mappings);
	        !_this.__kb.statics || createStaticObservables(_this, model);
	        _this.createObservables(model, _this.__kb.keys);
	        !kb.statistics || kb.statistics.register('ViewModel', _this);
	        return _this;
	      };
	    })(this));
	  }

	  ViewModel.prototype.destroy = function() {};

	  ViewModel.prototype.shareOptions = function() {};

	  ViewModel.prototype.createObservables = function(model, keys) {
	    var i, j, key, len, len1, mapping_info, ref1, rel_keys, vm_key;
	    if (!keys) {
	      if (this.__kb.keys || !model) {
	        return;
	      }
	      for (key in model.attributes) {
	        createObservable(this, model, key, this.__kb.create_options);
	      }
	      if (rel_keys = (ref1 = kb.orm) != null ? typeof ref1.keys === "function" ? ref1.keys(model) : void 0 : void 0) {
	        for (i = 0, len = rel_keys.length; i < len; i++) {
	          key = rel_keys[i];
	          createObservable(this, model, key, this.__kb.create_options);
	        }
	      }
	    } else if (_.isArray(keys)) {
	      for (j = 0, len1 = keys.length; j < len1; j++) {
	        key = keys[j];
	        createObservable(this, model, key, this.__kb.create_options);
	      }
	    } else {
	      for (key in keys) {
	        mapping_info = keys[key];
	        if (!(vm_key = assignViewModelKey(this, key))) {
	          continue;
	        }
	        if (!_.isString(mapping_info)) {
	          mapping_info.key || (mapping_info.key = vm_key);
	        }
	        this[vm_key] = this.__kb.view_model[vm_key] = kb.observable(model, mapping_info, this.__kb.create_options, this);
	      }
	    }
	  };

	  return ViewModel;

	})();

	kb.viewModel = function(model, options, view_model) {};


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var KEYS_PUBLISH, _, kb, ko, ref;

	ref = kb = __webpack_require__(2), _ = ref._, ko = ref.ko;

	__webpack_require__(26);

	KEYS_PUBLISH = ['destroy', 'setToDefault'];

	module.exports = kb.DefaultObservable = (function() {
	  function DefaultObservable(target_observable, dv) {}

	  DefaultObservable.prototype.destroy = function() {};

	  DefaultObservable.prototype.setToDefault = function() {};

	  return DefaultObservable;

	})();

	kb.defaultObservable = function(target, default_value) {};

	kb.observableDefault = kb.defaultObservable;


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var _, kb, ko, ref;

	ref = kb = __webpack_require__(2), _ = ref._, ko = ref.ko;

	kb.Observable.prototype.setToDefault = function() {};

	kb.ViewModel.prototype.setToDefault = function() {};

	kb.utils.setToDefault = function(obj) {};


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var _, arraySlice, kb, ko, ref;

	ref = kb = __webpack_require__(2), _ = ref._, ko = ref.ko;

	arraySlice = Array.prototype.slice;

	kb.toFormattedString = function(format) {};

	kb.parseFormattedString = function(string, format) {};

	module.exports = kb.FormattedObservable = (function() {
	  function FormattedObservable(format, args) {}

	  FormattedObservable.prototype.destroy = function() {};

	  return FormattedObservable;

	})();

	kb.formattedObservable = function(format, args) {};

	kb.observableFormatted = kb.formattedObservable;


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var KEYS_PUBLISH, _, kb, ko, ref;

	ref = kb = __webpack_require__(2), _ = ref._, ko = ref.ko;

	KEYS_PUBLISH = ['destroy', 'observedValue', 'resetToCurrent'];

	kb.locale_manager || (kb.locale_manager = void 0);

	module.exports = kb.LocalizedObservable = (function() {
	  LocalizedObservable.extend = kb.extend;

	  function LocalizedObservable(value1, options, vm) {}

	  LocalizedObservable.prototype.destroy = function() {};

	  LocalizedObservable.prototype.resetToCurrent = function() {};

	  LocalizedObservable.prototype.observedValue = function(value) {};

	  LocalizedObservable.prototype._onLocaleChange = function() {};

	  return LocalizedObservable;

	})();

	kb.localizedObservable = function(value, options, view_model) {};

	kb.observableLocalized = kb.localizedObservable;


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var KEYS_PUBLISH, _, kb, ko, ref;

	ref = kb = __webpack_require__(2), _ = ref._, ko = ref.ko;

	KEYS_PUBLISH = ['destroy'];

	module.exports = kb.TriggeredObservable = (function() {
	  function TriggeredObservable(emitter, event_selector1) {
	    var observable;
	    this.event_selector = event_selector1;
	    emitter || kb._throwMissing(this, 'emitter');
	    this.event_selector || kb._throwMissing(this, 'event_selector');
	    this.vo = ko.observable();
	    observable = kb.utils.wrappedObservable(this, ko.computed((function(_this) {
	      return function() {
	        return _this.vo();
	      };
	    })(this)));
	    kb.publishMethods(observable, this, KEYS_PUBLISH);
	    kb.utils.wrappedEventWatcher(this, new kb.EventWatcher(emitter, this, {
	      emitter: _.bind(this.emitter, this),
	      update: _.bind(this.update, this),
	      event_selector: this.event_selector
	    }));
	    return observable;
	  }

	  TriggeredObservable.prototype.destroy = function() {};

	  TriggeredObservable.prototype.emitter = function(new_emitter) {
	    if ((arguments.length === 0) || (this.ee === new_emitter)) {
	      return this.ee;
	    }
	    if ((this.ee = new_emitter)) {
	      return this.update();
	    }
	  };

	  TriggeredObservable.prototype.update = function() {
	    if (!this.ee) {
	      return;
	    }
	    if (this.vo() !== this.ee) {
	      return this.vo(this.ee);
	    } else {
	      return this.vo.valueHasMutated();
	    }
	  };

	  return TriggeredObservable;

	})();

	kb.triggeredObservable = function(emitter, event_selector) {
	  return new kb.TriggeredObservable(emitter, event_selector);
	};

	kb.observableTriggered = kb.triggeredObservable;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var $, _, callOrGet, kb, ko, ref;

	ref = kb = __webpack_require__(2), _ = ref._, ko = ref.ko, $ = ref.$;

	__webpack_require__(31);

	callOrGet = function(value) {};

	module.exports = kb.Validation = (function() {
	  function Validation() {}

	  return Validation;

	})();

	kb.valueValidator = function(value, bindings, validation_options) {};

	kb.inputValidator = function(view_model, el, validation_options) {};

	kb.formValidator = function(view_model, el) {};


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var $, EMAIL_REGEXP, NUMBER_REGEXP, URL_REGEXP, _, kb, ko, ref;

	ref = kb = __webpack_require__(2), _ = ref._, ko = ref.ko, $ = ref.$;

	URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;

	EMAIL_REGEXP = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$/;

	NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;

	kb.valid = {
	  required: function(value) {},
	  url: function(value) {},
	  email: function(value) {},
	  number: function(value) {}
	};

	kb.hasChangedFn = function(model) {};

	kb.minLengthFn = function(length) {};

	kb.uniqueValueFn = function(model, key, collection) {};

	kb.untilTrueFn = function(stand_in, fn, model) {};

	kb.untilFalseFn = function(stand_in, fn, model) {};


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	  knockback.js 1.0.0
	  Copyright (c)  2011-2014 Kevin Malakoff.
	  License: MIT (http://www.opensource.org/licenses/mit-license.php)
	  Source: https://github.com/kmalakoff/knockback
	  Dependencies: Knockout.js, Backbone.js, and Underscore.js (or LoDash.js).
	  Optional dependencies: Backbone.ModelRef.js and BackboneORM.
	 */
	var i, kb, key, len, ref;

	module.exports = kb = __webpack_require__(2);

	kb.configure = __webpack_require__(8);

	kb.modules = {
	  underscore: kb._,
	  backbone: kb.Parse || kb.Backbone,
	  knockout: kb.ko
	};

	if (typeof window !== "undefined" && window !== null) {
	  ref = ['_', 'Backbone', 'Parse', 'ko', '$'];
	  for (i = 0, len = ref.length; i < len; i++) {
	    key = ref[i];
	    if (kb[key] && !Object.prototype.hasOwnProperty.call(window, key)) {
	      window[key] = kb[key];
	    }
	  }
	}


/***/ }
/******/ ])
});
;